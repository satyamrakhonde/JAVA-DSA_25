STACK PATTERNS: Generalized
1ï¸âƒ£ Parentheses / String Stack Pattern

Goal: Check balance, remove invalid characters, or build valid strings.

Problem Examples:
Valid Parentheses (LC 20)
Min Add to Make Parentheses Valid (LC 921)
Remove Adjacent Duplicates (LC 1047)


General Pattern / Steps:

Traverse the string/array
Push â€œopenâ€ symbols or characters onto stack
Pop from stack when you find a matching â€œcloseâ€ symbol
For removals or counts: use stack size or top to determine what to remove/keep
Edge: if stack empty â†’ unbalanced or default value



Key Intuition:

Stack keeps unmatched items
Helps process LIFO (last in first out) problems in strings


2ï¸âƒ£ Monotonic Stack Pattern

Goal: Find next/previous greater/smaller element efficiently

Problem Examples:
Next Greater Element I / II
Next Smaller Element
Daily Temperatures
Stock Span Problem
Largest Rectangle in Histogram



General Pattern / Steps:
Decide direction: left â†’ right, right â†’ left
Decide stack type: decreasing or increasing (monotonic)

Traverse array:
While stack not empty AND current number breaks monotonicity â†’ pop elements
Update map/result for popped elements
Push current element (or index) onto stack
Optional: circular array â†’ loop twice or use modulo


Key Intuition:
Stack holds elements whose next/previous â€œspecialâ€ element hasnâ€™t been found yet
Always maintain monotonic order
Pop only when current element satisfies the condition (greater/smaller)



3ï¸âƒ£ Stack Design / Min Stack Pattern
Goal: Maintain extra info like min/max in O(1) while doing push/pop

Problem Examples:
Min Stack (LC 155)
Implement Stack using Queues


General Pattern / Steps:
Use extra stack or pair to store auxiliary info (min, max, count)
On push: update both main stack and auxiliary stack
On pop: remove from both
On query: peek top of auxiliary stack for min/max


Key Intuition:
Stack can be augmented with additional info
Never traverse to find min/max â†’ store dynamically


4ï¸âƒ£ Simulation / Special Processing Pattern
Goal: Solve problems where stack simulates a process or collision


Problem Examples:
Asteroid Collision (LC 735)
Remove K Digits (LC 402)
132 Pattern (LC 456)


General Pattern / Steps:
Traverse array/sequence
Use stack to keep track of â€œactive elementsâ€
While condition fails (collision / smaller / invalid) â†’ pop or remove
Push current element if valid / survives
Return final stack as result


Key Intuition:
Stack represents the â€œstateâ€ of the sequence so far
Pop when new element changes the state
Commonly used in greedy decisions


âœ… TL;DR â€“ How to recognize pattern
Pattern	Recognize it by	Stack use
Parentheses / String	Balance / matching / removal	Track unmatched symbols
Monotonic Stack	Next/prev greater/smaller	Track â€œwaitingâ€ elements in decreasing/increasing order
Stack Design	Maintain min/max or special query	Augment stack with auxiliary info
Simulation / Special	Sequence/state changes, collisions	Stack represents current state, pop when invalid

ğŸ’¡ Pro tip:
Whenever you see a problem with:

â€œNext greater / smallerâ€ â†’ Monotonic stack

â€œValid parentheses / removalâ€ â†’ String/Parentheses stack

â€œMin / max retrievalâ€ â†’ Design / augmented stack

â€œCollisions / greedy processingâ€ â†’ Simulation stack

You can immediately think â€œstack to store active or waiting elementsâ€.